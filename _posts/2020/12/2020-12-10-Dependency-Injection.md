---
layout: post
title: Dependency Inversion Principle - почему все забивают?
---
Постоянно встречаю в проекте код, который нарушает этот принцип. Почему разработчики предпочитаю забить?

Пример, который, встретил в одном из наших проектов:
```php
class B {}
class A {
    /**
    * @var B
    */
    private $b;
    public function __construct() {
        $this->b = new B();
    }
}
```
Создание объекта тоже выглядит просто:
```php 
$a = new A();
```
Следуя DIP мы должны писать иначе.

### DIP нас заставит создать больше файлов с кодом и написать больше строк:
```php
interface InterfaceB {}

class B implements InterfaceB {}

class A {
    /**
    * @var InterfaceB
    */
    private $b;
    public function __construct(InterfaceB $b) {
        $this->b = $b;
    }
}
```

### Теперь мы должны страдать при создании экземпляра
```php
# у нас DIP и мы должы страдать
$a = new A(new B());
```
**Усложнение создания объекта** - это главная причина почему разработчики избегают DIP. 
Нам легко создать несколько файлов и написать шаблонный код, а вот создание объекта `$a = new A(new B());` считается ужасным.
Программиста разрывают сомнения стоит ли это прятать или оставить, делать ли фабрику, использовать di контейнеры или локаторы.

Разумное соблюдение DIP сильно улучшит ваш код. Невозможность протестировать свой объект, связанность классов, которые не должны быть связаны - намного жуже чем  `$a = new A(new B());`. 
