---
layout: post
title: Phprector побеждает legacy
categories: рефакторинг legacy
---

Phprector(далее просто - ректор) инструмент для быстрого обновления и рефакторинга php кода. Миссия phprector - удалим слово "legacy" из словаря. 

У меня планируется доклад про этот  библиотеку на php митапе на канале [ЭФКО Цифровые Решения](https://www.youtube.com/channel/UC9oEZbCfEPfzdRKYUrfcueA). Я постараюсь подготовить проговорить основные тезисы здесь в блоге. 


## План

* Что такое phprector
* Почему ректор, не линтер
* Выводы: Перспективы phprector и кому он точно нужен phprector 
* Правила и наборы правил
* Проблемы автоматического рефакторинга
* Проблемы phprector
* Что нам дал ректор? 
* Phprector в pipeline


### Что такое phprector?

Phprector - это инструмент командной строки, который умеет изменять код согласно заданным правилам. При помощи ректор вы сможете обновить ваш проект до новой версии php, обновить библиотеки такие как PHPUnit и даже используемый фреймворк. 

### Почему ректор не линтер?

На всякий случай скажу, что линтер - это инструмент, который проверяет соотвествие кода некоторым стандартам или даже сама приводит код к этим стандартам. 
Если в вашем проекте еще нет автоматической проверки кода на соотвествие стандартам - то обязательно займитесь этим. Ректор вам, скорее всего, не нужен. 

Если линтер сможет исправить расстановку пробелов, то ректор умеет делать настоящий рефакторинг. 

### Вывод: Перспективы ректор

Однозначно за такими проектами как ректор будущее и их будет еще много для всех популярных языков программирования. 
Триллионы строк кода выжигают миллиардные бюджеты на их поддержку и уборку легаси. 
Экономия даже 1% - это коллосальные деньги. 
Если для вашего языка еще нет такого проекта - самое время его написать.



### Вывод: Кому нужен ректор?

В этот раз вывод не получилось разместить вначале, но все таки я не буду тянуть с выводом до конца. 

Ректор подойдет:

* Есть тот самый legacy. Много legacy.
* У вас нет денег, чтобы переписать всё.
* Ваш код соответветсвует PSR-4 или выше, настроены линтеры. 
* Хорошее покрытие тестами или тестерами, которые смогут найти баги.
* Вам хочется заняться кодовой базой, но вы не знаете куда двигаться. 
* Вам нужно обновить что-то из того что умеет ректор.
* Вы начинаете новый проект с сомнительной командой.

### Правила и наборы правил

Устновить ректор в проект легко, просто подключите зависимость в composer.

```shell
	composer require rector/rector --dev
```

Затем инициируйте ректор, это действие создаст файл rector.php в корне проекта, при помощи которого можно удобно конфигурировать ректор для вашего проекта. 

```shell
	vendor/bin/rector init
```

Я уже рассказывал [здесь](https://otis22.github.io/%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0,/legacy,/tools/2021/02/18/how-to-migrate-to-7.2.html) как мы обновляли код с php 5.3 на php 7.2 несколько лет назад. Суть в том, что мы запускали чекер, который находил то, что нужно переписать. Мы описывали правила, по которым нужно переписать код, а затем стажеры переписывали этот код. 

Ректор работает так же, только без стажеров. Ректор умеет разбирать php при помощи библиотеки [PHP-Parser](https://github.com/nikic/PHP-Parser/).

Он содержит правила, которые находят код, который нужно преобразовать и преобразовует его по определенным правилам.

Например: 

```diff
 $items = [];
-foreach ($items as $key => $value) {
+foreach ($items as $value) {
     $result = $value;
 }

```

Ректор найдет конструкцию `foreach` в которой не используется переменная `$key` и ректор отрефакторит этот участок. 

Правила в ректор объеденены в наборы для удобства подключения однотипных правил. При начальной инициализации включаются правила из набора DEAD_CODE.

Есть еще интересные наборы, на которые стоит обратить внимание: CodeQuality, TypeDeclaration и наборы с фичами языка. 

Есть возможность и полуавтоматического рефакторинга. Не буду на неё отвлекаться. 


### Проблемы автоматического рефакторинга


Установив ректор в свой репозиторий, можно начать применять правила к коду. Хорошая идея начать с набора правил DEAD_CODE. Применяйте правила по одному к коду и запускайте тесты. 

Я использовал набор DEAD_CODE добавляя 5-10 новых правил каждую неделю. Для этого нужно их скопировать из набора. В файле rector.php найдите строку $containerConfigurator->import(SetList::DEAD_CODE);  зажмите CTRL и кликните на DEAD_CODE.

Затем перейдите в сам файл с правилами public const DEAD_CODE = __DIR__ . '/../../../config/set/dead-code.php'; кликаем под CTRL на dead-code.php который выглядят так:

```php
    $services = $containerConfigurator->services();
    $services->set(\Rector\DeadCode\Rector\If_\UnwrapFutureCompatibleIfFunctionExistsRector::class);
    $services->set(\Rector\DeadCode\Rector\If_\UnwrapFutureCompatibleIfPhpVersionRector::class);
    $services->set(\Rector\DeadCode\Rector\Cast\RecastingRemovalRector::class);
...
```


Закомментируйте строку $containerConfigurator->import(SetList::DEAD_CODE); и вставьте правила в ректор. Закомментируйте все правила и раскомментируйте их по одному правилу или группами.



RemoveEmptyClassMethod иногда удаляет нужные методы, например ломает все синглтоны

```php
    private function __clone()
    {
        throw new \Exception("I am a singleton!!!");
    }
```


RemoveUnusedPrivateMethod удаляет нужные методы, у нас был яркий конфликт, когда я применил это правила не просмотрел все классы, а там был такой код.

```php
class Tool {

	public function exec(): void
	{
		//$this->doWork('one');
		//$this->doWork('two');
		//$this->doWork('three');
	}

	private function doWork($name): void
	{
		...
	}

}

```


Если не придираться к дизайну, чтобы ректор отработал правильно, достаточно было просто раскомментировать первый вызов. Тем неменее, конфликт был шумным.


Давайте последнюю проблему рассмотрим. Правило RecastingRemovalRector.

Есть вот такой код: 


```php

$id = (int)$_GET('id');

$post = Post::find((int) $id);

```

Очевидно, что второе приведение типов здесь лишнее. Ректор его удалит и это правильно, но ректор еще в качестве указания на тип рассматривает и комментарии в коде. 

```php
/**
 * Class Timesheet
...
 * @property string $title
...
 * @property int $action_id
 * @property int $clinic_id
 */
class Timesheet
{
```

И есть вот такой код в программе, который использует свойства этого класса:

```php
$timesheet->shedule_id = (int) $this->timesheetRow->shedule_id;
$timesheet->action_id = (int) $this->timesheetRow->action_id;
$timesheet->title = (string) $this->timesheetRow->title;
```
Ректор логично предлагает убрать двойное приведение типов ибо программист же написал `int`. Но видимо, программист просто ошибься в комментариях и в данном случае нужно помочь ректору и исправить комментарии согласно логике. То есть свойство может быть и null, не `int` а `?int`

```php
/**
 * Class Timesheet
...
 * @property ?string $title
...
 * @property ?int $action_id
 * @property ?int $clinic_id
 */
```

В общем, ректор не делает ошибок там, где код написан нормально. Если ректор ошибается, то скорее всего мы наблюдаем какую-то дичь, которую сотворил программист и которую без 100 грамм тяжело понять даже ему самому. 

todo: Решить нужны ли еще такие случаи?

### Проблемы использования phprector

На Ветменеджер ректор проверяет около 250к строк и на моём рабочем ноутбуке холодный запуск ректор занимает 2m50.245s.
Это немало, комфорта разработчикам не добавляет. 

Еще ректор очень плохо справляется со скриптовым лапшекодом. Особенно если в нем встречаются `require` и `include`. 
Благодаря ректору я наше в проекте несколько таких подключений там где их не должно было быть и где программист их аккуратно спрятал за `phpcs:ignore`.

У нас есть часть кода, которая не привидена к PSR4/12 стандарту и ректор на этом куске ругается страшными ошибками. К чести ректора, он быстро развивается и многие участки кода, которые он раньше не переваривал он начинает понимать с обновлениями. Верю в развитие этого проекта.

Ректор плохо себя вел с старым проектом на laravel, он не понимал `compact` и ломал все что с ним связано. У меня не было возможности попробовать новые версии ректор, я думаю, что работать с фреймворками он может и проблемы могли быть уже исправлены.


### Что нам дал ректор

Мы еще не использовали все правила ректор. Мы применили только набор DEAD_CODE и я обновил PHPUnit c 6й версии до последней. 

Самое главное, ректор дал неплохой толчок и направление движения. Когда перед тобой тысячи строк говнокода сложно понять как все это прообразовать во что-то приличное не привлекая внимания санитаров и не просрав все сроки и бюджеты. Внедряя ректор я точно знал, что сначала нужно отладить запуск ректора, он падал из-за кривого кода. 

Затем нужно было запускать и отлаживать правила из набора по одному. Иногда ректор тоже находил места требующие ручного рефакторинга. Ректор постоянно говорил что делать и помогал, выполнял много рутинной работы. Удалось удалить тысячи строк кода и еще столько же привести к приличному виду. 

Обновление PHPUnit заняло у меня до 2х часов, с постепенным применением правил и каждый рас с переходом на новую версию PHPUnit. При этом у нас более 1000 тестов юнит, интеграционные и тесты с использованием селениум. Ректор не справился только с `Assert::assertContains() must be iterable, string given` пришлось исправить это руками. 


### Phprector в pipeline

todo: Написать почему встроили в пайплайн, какие есть варианты борьбы с долгим запуском



## Ссылки

* [Репозиторий](https://github.com/rectorphp/rector)
* [Главный сайт](https://getrector.org/)
* [Как встроить автофикс в Pipeline](https://getrector.org/blog/2020/10/05/how-to-make-rector-contribute-your-pull-requests-every-day)
* [Phpinspection Phpstorm Plugin](https://plugins.jetbrains.com/plugin/7622-php-inspections-ea-extended-)
